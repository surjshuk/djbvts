// src/lib/report-pdf.ts
import QRCode from "qrcode";

// convert mm → pt (1 inch = 25.4 mm, 1 inch = 72 pt)
const mmToPt = (mm: number) => (mm * 72) / 25.4;

// Your custom page size: 297 × 241 mm
const PAGE_WIDTH_PT  = mmToPt(297); // ≈ 841.89 pt
const PAGE_HEIGHT_PT = mmToPt(241); // ≈ 683.15 pt

type Row = {
  area: string;
  vehicleNo: string;
  tankerType: string;
  transporterName: string;
  tripDistanceKm: string;
  engineHours: string;
  tripCount: number;
};

function fmtDate(d: Date) {
  const dd = String(d.getDate()).padStart(2, "0");
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const yy = d.getFullYear();
  return `${dd}-${mm}-${yy}`;
}

export async function buildReportPdf({
  title,
  dateFrom,
  dateTo,
  generatedAt,
  generatedByEmail,
  rows,
  verificationUrl,
}: {
  title: string;
  dateFrom: Date;
  dateTo: Date;
  generatedAt: Date;
  generatedByEmail: string;
  rows: Row[];
  verificationUrl: string;
}): Promise<Buffer> {
  const { default: PDFDocument } = await import("pdfkit");

  // set custom size (portrait). For landscape, swap width/height.
  const doc = new PDFDocument({
    size: [PAGE_WIDTH_PT, PAGE_HEIGHT_PT],
    margin: 36,
  });

  const chunks: Buffer[] = [];
  doc.on("data", (c) => chunks.push(c));
  const done = new Promise<Buffer>((resolve) => doc.on("end", () => resolve(Buffer.concat(chunks))));

  // Header text
  doc.fontSize(16).fillColor("#000").text(title, { align: "center" }).moveDown(0.2);
  doc.fontSize(10).text(`(From: ${fmtDate(dateFrom)}  To: ${fmtDate(dateTo)})`, { align: "center" }).moveDown();
  doc
    .fontSize(10)
    .text(
      `System Generated Report, Generated at: ${fmtDate(generatedAt)} ${generatedAt.toTimeString().slice(0,5)}`,
      { align: "center" }
    )
    .moveDown();

  // Table layout
  const left = doc.page.margins.left;
  const right = PAGE_WIDTH_PT - doc.page.margins.right;
  const tableWidth = right - left;

  const cols = [
    { label: "S.No", width: 50 },
    { label: "Area", width: 110 },
    { label: "Vehicle No.", width: 110 },
    { label: "Tanker Type", width: 110 },
    { label: "Transporter Name", width: 150 },
    { label: "Report Date", width: 100 },
    { label: "Trip Distance / Engine Hr", width: 150 },
    { label: "Trip Count", width: 70 },
  ];

  // If widths don't fit exactly, you can compute widths proportionally using tableWidth.

  // Draw BLUE header band and white titles
  let y = doc.y + 10;
  const headerHeight = 22;
  doc
    .save()
    .rect(left, y, tableWidth, headerHeight)
    .fill("#1976d2"); // blue header (e.g., Material blue 700)

  // Column titles in white
  doc.fillColor("#fff").fontSize(9);
  let x = left;
  for (const c of cols) {
    doc.text(c.label, x + 4, y + 5, { width: c.width - 8, align: "left" });
    x += c.width;
  }
  doc.restore();

  // Divider line under header
  y += headerHeight;
  doc.moveTo(left, y).lineTo(right, y).strokeColor("#999").stroke();

  // Body rows in black
  y += 6;
  doc.fillColor("#000").fontSize(9);
  rows.forEach((r, i) => {
    x = left;
    const cells = [
      String(i + 1),
      r.area,
      r.vehicleNo,
      r.tankerType,
      r.transporterName,
      fmtDate(dateFrom),
      `${r.tripDistanceKm} km / ${r.engineHours} hr`,
      String(r.tripCount),
    ];
    cells.forEach((val, idx) => {
      const w = cols[idx].width;
      doc.text(val, x + 4, y, { width: w - 8, align: "left" });
      x += w;
    });
    y += 16;
    // optional row lines:
    // doc.moveTo(left, y).lineTo(right, y).strokeColor("#eee").stroke();
  });

  // QR footer (unchanged)
  const qrDataUrl = await QRCode.toDataURL(verificationUrl);
  const qrBuf = Buffer.from(qrDataUrl.split(",")[1], "base64");
  const footerY = PAGE_HEIGHT_PT - doc.page.margins.bottom - 10;
  doc.image(qrBuf, left, footerY - 80, { width: 70 });
  doc
    .fontSize(9)
    .text(
      `Generated by :- ${generatedByEmail} , Report Generated At :- ${fmtDate(generatedAt)} ${generatedAt.toTimeString().slice(0,5)}`,
      left + 90,
      footerY - 50,
      { width: tableWidth - 90 }
    );

  doc.end();
  return done;
}
